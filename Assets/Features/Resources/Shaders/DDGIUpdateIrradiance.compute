#pragma kernel DDGIUpdateIrradiance

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
#include "Lib/DDGIInputs.hlsl"
#include "Lib/DDGIFuncs.hlsl"

#define CACHE_SIZE PROBE_IRRADIANCE_TEXELS * PROBE_IRRADIANCE_TEXELS
groupshared float3 RadianceCache[CACHE_SIZE];
groupshared float3 DirectionCache[CACHE_SIZE];

static const uint BORDER_TEXELS = PROBE_IRRADIANCE_TEXELS * 4 + 4;
static const uint4 BORDER_OFFSETS[BORDER_TEXELS] = 
{
    uint4(6, 6, 0, 0), 
    uint4(6, 1, 1, 0), uint4(5, 1, 2, 0), uint4(4, 1, 3, 0), uint4(3, 1, 4, 0), uint4(2, 1, 5, 0), uint4(1, 1, 6, 0),
    uint4(1, 6, 7, 0),
    uint4(1, 6, 0, 1), uint4(1, 5, 0, 2), uint4(1, 4, 0, 3), uint4(1, 3, 0, 4), uint4(1, 2, 0, 5), uint4(1, 1, 0, 6),
    uint4(6, 1, 0, 7),
    uint4(6, 6, 7, 1), uint4(6, 5, 7, 2), uint4(6, 4, 7, 3), uint4(6, 3, 7, 4), uint4(6, 2, 7, 5), uint4(6, 1, 7, 6),
    uint4(1, 1, 7, 7),
    uint4(6, 6, 1, 7), uint4(5, 6, 2, 7), uint4(4, 6, 3, 7), uint4(3, 6, 4, 7), uint4(2, 6, 5, 7), uint4(1, 6, 6, 7) 
};

// Thread group count: (num_probe_flat, 1, 1)
// 每个线程组代表一个Probe，线程组内的每一个线程处理该Probe对应的八面体投影Texel
// 每个线程都会从DDGI Ray Trace阶段得到的RayBuffer中获取场景当前帧的辐照度数据，计算全局光照后，与前一帧的辐照度数据混合，存储进对应Texel
[numthreads(PROBE_IRRADIANCE_TEXELS, PROBE_IRRADIANCE_TEXELS, 1)]
void DDGIUpdateIrradiance (
    uint3 GroupId           : SV_GroupID,
    uint3 GroupThreadId     : SV_GroupThreadID,
    uint3 DispatchThreadId  : SV_DispatchThreadID,
    uint  GroupIndex        : SV_GroupIndex)
{
    uint  probeIdx              = GroupId.x;
    uint3 probeGridCoords       = GetProbeGridCoordFromIndex(probeIdx);
    uint2 texelLocation         = GetProbeTexelCoord(probeGridCoords, PROBE_IRRADIANCE_TEXELS);
    uint2 cornerTexelLocation   = texelLocation - 1u;
    texelLocation += GroupThreadId.xy;

    float3 prevRadiance = LOAD_TEXTURE2D_LOD(_IrradianceTextureHistory, texelLocation, 0).rgb;

    float3   probeDirection = DecodeNormalOctahedron(((GroupThreadId.xy + 0.5f) / (float)PROBE_IRRADIANCE_TEXELS) * 2 - 1);
    float3x3 randomRotation = AngleAxis3x3(_RandomAngle, _RandomVector);

    float weightSum = 0.0f;
    float3 result = 0.0f;
    uint remainingRays = _RaysPerProbe;
    uint offset = 0;
    while(remainingRays > 0)
    {
        uint numRays = min(CACHE_SIZE, remainingRays);
        if(GroupIndex < numRays)
        {
            RadianceCache[GroupIndex] = RayBuffer[probeIdx * _MaxRaysPerProbe + offset + GroupIndex].rgb;
            DirectionCache[GroupIndex] = GetRayDirection(offset + GroupIndex, _RaysPerProbe, randomRotation);
        }
        GroupMemoryBarrierWithGroupSync();

        for(uint i = 0; i < numRays; ++i)
        {
            float3 radiance = RadianceCache[i].rgb;
            float3 direction = DirectionCache[i];
            float weight = saturate(dot(probeDirection, direction));
            result += weight * radiance;
            weightSum += weight;
        }

        remainingRays -= numRays;
        offset += numRays;
    }

    const float epsilon = 1e-9f * float(_RaysPerProbe);
    result *= 1.0f / max(2.0f * weightSum, epsilon);

    result = pow(abs(result), rcp(5.0f));
    const float historyBlendWeight = saturate(1.0f - _HistoryBlendWeight);
    result = lerp(prevRadiance, result, historyBlendWeight);

    _IrradianceTexture[texelLocation] = float4(result, 1);

    GroupMemoryBarrierWithGroupSync();

    for (uint index = GroupIndex; index < BORDER_TEXELS; index += PROBE_IRRADIANCE_TEXELS * PROBE_IRRADIANCE_TEXELS)
    {
        const uint2 sourceIndex = cornerTexelLocation + BORDER_OFFSETS[index].xy;
        const uint2 targetIndex = cornerTexelLocation + BORDER_OFFSETS[index].zw;
        _IrradianceTexture[targetIndex] = _IrradianceTexture[sourceIndex];
    }
}
